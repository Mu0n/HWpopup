package mic;

import VASSAL.build.module.documentation.HelpFile;
import VASSAL.command.ChangeTracker;
import VASSAL.command.Command;
import VASSAL.command.MoveTracker;
import VASSAL.counters.*;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;

/**
 * Created by Mic on 04/12/2018.
 *
 * this file is for all programmatic reactions to ',', '.' and 'ctrl-r' commands issued to this new style of dial
 * New style of dial:
 *
 * 1) looks like the open face 2nd edition dial instead of the 1st edition
 * 2) no more additional graphics due to the masked/hidden side - a simple eye-with-slash icon will be used to indicate the hidden mode of the dial (icon at center)
 * 3) when in reveal mode, the selected move (at the top) will be copied, larger, in the center and rotations can't be done at all
 * 4) when in hidden mode, dial rotation commands will only tweak the rotation of the faceplate for the owner of the dial, not for any other player
 * 5) The pilot name in text (white text over black background) above the dial; the ship name in text (same colors) under the dial, no more icon gfx to manage
 * 6) a player can't cheat anymore by swapping mask gfx by a transparent empty png
 * 7) the open face dial has to be kept in OTA2 - no mistakes are allowed because patches can't happen, unless a download all is forced in the content checker
 * 8) File name should be: D2e_'ship name from contracted manifest file names'.jpg
 * 9) Dial graphics should be generated by Mike's tool when he has time to implement it, otherwise generated by me in an outside program or from dialgen + photoshop
 * 10) new dial graphics added when a ship graphic is added in the best case scenario as info pours in from previews.
 */

public class StemNuDial2e extends Decorator implements EditablePiece {
    public static final String ID = "StemNuDial2e";
    public boolean isHidden = false;

    public StemNuDial2e()  {
        this(null);
    }

    public StemNuDial2e(GamePiece piece)
        {setInner(piece); }

    @Override
    public void mySetState(String newState) {

    }
    @Override
    public String myGetState() {
        return "";
    }
    @Override
    public String myGetType() {
        return ID;
    }
    @Override
    protected KeyCommand[] myGetKeyCommands() {
        return new KeyCommand[0];
    }

    @Override
    public Command myKeyEvent(KeyStroke stroke) { return null; }

    @Override
    public Command keyEvent(KeyStroke stroke) {
        boolean hasSomethingHappened = false;

        Command result = piece.keyEvent(stroke);

        if (getOwnerOfThisDial() == Util.getCurrentPlayer().getSide()) {
            KeyStroke checkForCtrlRReleased = KeyStroke.getKeyStroke(KeyEvent.VK_R, KeyEvent.CTRL_DOWN_MASK, true);
            KeyStroke checkForCtrlRPressed = KeyStroke.getKeyStroke(KeyEvent.VK_R, KeyEvent.CTRL_DOWN_MASK, false);
            KeyStroke checkForCommaReleased = KeyStroke.getKeyStroke(KeyEvent.VK_COMMA, 0, true);
            KeyStroke checkForPeriodReleased = KeyStroke.getKeyStroke(KeyEvent.VK_PERIOD, 0, true);

            if(checkForCtrlRReleased.equals(stroke)) {
                hasSomethingHappened = true;
                if(isHidden) { // about to reveal the dial
                    isHidden = false;
                    Embellishment chosenMoveEmb = (Embellishment)Util.getEmbellishment(piece,"Layer - Chosen Move");
                    Embellishment chosenSpeedEmb = (Embellishment)Util.getEmbellishment(piece, "Layer - Chosen Speed");
                    chosenMoveEmb.setValue(1);
                    chosenSpeedEmb.setValue(1);
                    String dialString = piece.getProperty("dialstring").toString();
                    Util.logToChatWithoutUndo("revealed this dialstring " + dialString);
                } else { // about to hide the dial
                    isHidden = true;
                    Embellishment chosenMoveEmb = (Embellishment)Util.getEmbellishment(piece,"Layer - Chosen Move");
                    Embellishment chosenSpeedEmb = (Embellishment)Util.getEmbellishment(piece, "Layer - Chosen Speed");
                    chosenMoveEmb.setValue(0);
                    chosenSpeedEmb.setValue(0);
                }
            }
            else if(checkForCommaReleased.equals(stroke)){ //rotate left, move--
                hasSomethingHappened = true;
                String dialString = piece.getProperty("dialstring").toString();
                String[] values = dialString.split(",");

                int nbOfMoves = values.length;
                String currentMove = piece.getProperty("selectedMove").toString();
                int currentMoveInt = Integer.parseInt(currentMove);

                if(currentMoveInt == 1) currentMoveInt = nbOfMoves; //cycle around
                else currentMoveInt--;

                currentMove = ""+currentMoveInt;
                piece.setProperty("selectedMove", currentMove);

                String newMove = values[currentMoveInt-1];
                int newMoveSpeed = getLayerFromMoveCode(newMove);

                Embellishment chosenSpeedEmb = (Embellishment)Util.getEmbellishment(piece, "Layer - Chosen Speed");
                chosenSpeedEmb.setValue(newMoveSpeed);


            } else if(checkForPeriodReleased.equals(stroke)){
                hasSomethingHappened = true;
                String dialString = piece.getProperty("dialstring").toString();
                String[] values = dialString.split(",");

                int nbOfMoves = values.length;
                String currentMove = piece.getProperty("selectedMove").toString();
                int currentMoveInt = Integer.parseInt(currentMove);

                if(currentMoveInt == nbOfMoves) currentMoveInt = 1; //cycle around
                else currentMoveInt++;

                currentMove = ""+currentMoveInt;
                piece.setProperty("selectedMove", currentMove);

                String newMove = values[currentMoveInt-1];
                int newMoveSpeed = getLayerFromMoveCode(newMove);

                Embellishment chosenSpeedEmb = (Embellishment)Util.getEmbellishment(piece, "Layer - Chosen Speed");
                chosenSpeedEmb.setValue(newMoveSpeed);

            }
        } else { // get scolded for not owning the dial that was manipulated
            Util.logToChatWithoutUndo("You (player " + Util.getCurrentPlayer().getSide() + ") are not the owner of this dial, player " + getOwnerOfThisDial() + " is.");
        }
        if(hasSomethingHappened) return result;
        return piece.keyEvent(stroke);
    }

    public int getLayerFromMoveCode(String code){
        return Integer.parseInt(code.substring(0,1)) + 1;
    }
    public int getOwnerOfThisDial(){
        GamePiece dialPiece = (GamePiece)this.piece;
        String ownerStr = dialPiece.getProperty("owner").toString();
        int ownerInt = Integer.parseInt(ownerStr);
        return ownerInt;
    }
    public String getDescription() {
        return "Custom StemNuDial (mic.StemNuDial2e)";
    }

    public void mySetType(String type) {

    }

    public HelpFile getHelpFile() {
        return null;
    }

    public void draw(Graphics g, int x, int y, Component obs, double zoom) {
        this.piece.draw(g, x, y, obs, zoom);
    }

    public Rectangle boundingBox() {
        return this.piece.boundingBox();
    }

    public Shape getShape() {
        return this.piece.getShape();
    }

    public String getName() {
        return this.piece.getName();
    }

    public static class buildHideCommand extends Command {
        GamePiece pieceInCommand;

        protected void buildHideCommand(GamePiece piece) {
            pieceInCommand = piece;
        }

        protected void executeCommand() {
            Embellishment chosenMoveEmb = (Embellishment)Util.getEmbellishment(pieceInCommand,"Layer - Chosen Move");
            Embellishment chosenSpeedEmb = (Embellishment)Util.getEmbellishment(pieceInCommand, "Layer - Chosen Speed");
            chosenMoveEmb.setValue(0);
            chosenSpeedEmb.setValue(0);
        }

        protected Command myUndoCommand() {
            return null;
        }
    }

}
