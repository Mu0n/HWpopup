package mic;

import VASSAL.build.GameModule;
import VASSAL.build.module.documentation.HelpFile;
import VASSAL.build.module.map.PieceMover;
import VASSAL.command.ChangeTracker;
import VASSAL.command.Command;
import VASSAL.command.CommandEncoder;
import VASSAL.command.MoveTracker;
import VASSAL.configure.HotKeyConfigurer;
import VASSAL.counters.*;
import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;

import static mic.Util.deserializeBase64Obj;
import static mic.Util.logToChat;
import static mic.Util.serializeToBase64;

/**
 * Created by Mic on 04/12/2018.
 *
 * this file is for all programmatic reactions to ',', '.' and 'ctrl-r' commands issued to this new style of dial
 * New style of dial:
 *
 * 1) looks like the open face 2nd edition dial instead of the 1st edition
 * 2) no more additional graphics due to the masked/hidden side - a simple eye-with-slash icon will be used to indicate the hidden mode of the dial (icon at center)
 * 3) when in reveal mode, the selected move (at the top) will be copied, larger, in the center and rotations can't be done at all
 * 4) when in hidden mode, dial rotation commands will only tweak the rotation of the faceplate for the owner of the dial, not for any other player
 * 5) The pilot name in text (white text over black background) above the dial; the ship name in text (same colors) under the dial, no more icon gfx to manage
 * 6) a player can't cheat anymore by swapping mask gfx by a transparent empty png
 * 7) the open face dial has to be kept in OTA2 - no mistakes are allowed because patches can't happen, unless a download all is forced in the content checker
 * 8) File name should be: D2e_'ship name from contracted manifest file names'.jpg
 * 9) Dial graphics should be generated by Mike's tool when he has time to implement it, otherwise generated by me in an outside program or from dialgen + photoshop
 * 10) new dial graphics added when a ship graphic is added in the best case scenario as info pours in from previews.
 */

public class StemNuDial2e extends Decorator implements EditablePiece, Serializable {
    public static final String ID = "StemNuDial2e";


    final public static Map<String, Integer> moveCodeWithColorToLayer = ImmutableMap.<String, Integer>builder()
            .put("FB", 1) //FORWARDS
            .put("FW", 2)
            .put("FR", 3)

            .put("TB", 4) //TURNS LEFT
            .put("TW", 5)
            .put("TR", 6)

            .put("YB", 7) //TURNS RIGHT
            .put("YW", 8)
            .put("YR", 9)

            .put("BB", 10) //BANKS LEFT
            .put("BW", 11)
            .put("BR", 12)

            .put("NB", 13)//BANKS RIGHT
            .put("NW", 14)
            .put("NR", 15)

            .put("LB", 16) //SLOOPS LEFT
            .put("LW", 17)
            .put("LR", 18)

            .put("PB", 19) //SLOOPS RIGHT
            .put("PW", 20)
            .put("PR", 21)

            .put("EB", 22) //TROLLS LEFT
            .put("EW", 23)
            .put("ER", 24)

            .put("RB", 25) //TROLLS RIGHT
            .put("RW", 26)
            .put("RR", 27)

            .put("AB", 28) //REVERSE BANK LEFT
            .put("AW", 29)
            .put("AR", 30)

            .put("SB", 31) //REVERSE STRAIGHT
            .put("SW", 32)
            .put("SR", 33)

            .put("DB", 34) //REVERSE BANK RIGHT
            .put("DW", 35)
            .put("DR", 36)

            .put("OB", 37) //STOP
            .put("OW", 38)
            .put("OR", 39)

            .put("KB", 40) //K-TURNS
            .put("KW", 41)
            .put("KR", 42)
            .build();
    final public static Map<String, KeyStroke> moveCodeToKeyStroke = ImmutableMap.<String, KeyStroke>builder()
            .put("1F", KeyStroke.getKeyStroke(KeyEvent.VK_1, KeyEvent.SHIFT_DOWN_MASK, false))
            .put("2F", KeyStroke.getKeyStroke(KeyEvent.VK_2, KeyEvent.SHIFT_DOWN_MASK, false))
            .put("3F", KeyStroke.getKeyStroke(KeyEvent.VK_3, KeyEvent.SHIFT_DOWN_MASK, false))
            .put("4F", KeyStroke.getKeyStroke(KeyEvent.VK_4, KeyEvent.SHIFT_DOWN_MASK, false))
            .put("5F", KeyStroke.getKeyStroke(KeyEvent.VK_5, KeyEvent.SHIFT_DOWN_MASK, false))
            .put("1T", KeyStroke.getKeyStroke(KeyEvent.VK_1, KeyEvent.CTRL_DOWN_MASK+KeyEvent.SHIFT_DOWN_MASK, false))
            .put("2T", KeyStroke.getKeyStroke(KeyEvent.VK_2, KeyEvent.CTRL_DOWN_MASK+KeyEvent.SHIFT_DOWN_MASK, false))
            .put("3T", KeyStroke.getKeyStroke(KeyEvent.VK_3, KeyEvent.CTRL_DOWN_MASK+KeyEvent.SHIFT_DOWN_MASK, false))
            .put("1Y", KeyStroke.getKeyStroke(KeyEvent.VK_1, KeyEvent.ALT_DOWN_MASK+KeyEvent.SHIFT_DOWN_MASK, false))
            .put("2Y", KeyStroke.getKeyStroke(KeyEvent.VK_2, KeyEvent.ALT_DOWN_MASK+KeyEvent.SHIFT_DOWN_MASK, false))
            .put("3Y", KeyStroke.getKeyStroke(KeyEvent.VK_3, KeyEvent.ALT_DOWN_MASK+KeyEvent.SHIFT_DOWN_MASK, false))
            .put("1B", KeyStroke.getKeyStroke(KeyEvent.VK_1, KeyEvent.CTRL_DOWN_MASK, false))
            .put("2B", KeyStroke.getKeyStroke(KeyEvent.VK_2, KeyEvent.CTRL_DOWN_MASK, false))
            .put("3B", KeyStroke.getKeyStroke(KeyEvent.VK_3, KeyEvent.CTRL_DOWN_MASK, false))
            .put("1N", KeyStroke.getKeyStroke(KeyEvent.VK_1, KeyEvent.ALT_DOWN_MASK, false))
            .put("2N", KeyStroke.getKeyStroke(KeyEvent.VK_2, KeyEvent.ALT_DOWN_MASK, false))
            .put("3N", KeyStroke.getKeyStroke(KeyEvent.VK_3, KeyEvent.ALT_DOWN_MASK, false))
            .put("1K", KeyStroke.getKeyStroke(KeyEvent.VK_1, KeyEvent.CTRL_DOWN_MASK+KeyEvent.ALT_DOWN_MASK, false))
            .put("2K", KeyStroke.getKeyStroke(KeyEvent.VK_2, KeyEvent.CTRL_DOWN_MASK+KeyEvent.ALT_DOWN_MASK, false))
            .put("3K", KeyStroke.getKeyStroke(KeyEvent.VK_3, KeyEvent.CTRL_DOWN_MASK+KeyEvent.ALT_DOWN_MASK, false))
            .put("4K", KeyStroke.getKeyStroke(KeyEvent.VK_4, KeyEvent.CTRL_DOWN_MASK+KeyEvent.ALT_DOWN_MASK, false))
            .put("5K", KeyStroke.getKeyStroke(KeyEvent.VK_5, KeyEvent.CTRL_DOWN_MASK+KeyEvent.ALT_DOWN_MASK, false))
            .put("1A", KeyStroke.getKeyStroke(KeyEvent.VK_6, KeyEvent.CTRL_DOWN_MASK, false))
            .put("1S", KeyStroke.getKeyStroke(KeyEvent.VK_6, KeyEvent.SHIFT_DOWN_MASK, false))
            .put("2S", KeyStroke.getKeyStroke(KeyEvent.VK_7, KeyEvent.SHIFT_DOWN_MASK, false))
            .put("1D", KeyStroke.getKeyStroke(KeyEvent.VK_6, KeyEvent.ALT_DOWN_MASK, false))
            .put("1L", KeyStroke.getKeyStroke(KeyEvent.VK_Q, KeyEvent.CTRL_DOWN_MASK, false))
            .put("2L", KeyStroke.getKeyStroke(KeyEvent.VK_W, KeyEvent.CTRL_DOWN_MASK, false))
            .put("3L", KeyStroke.getKeyStroke(KeyEvent.VK_E, KeyEvent.CTRL_DOWN_MASK, false))
            .put("1P", KeyStroke.getKeyStroke(KeyEvent.VK_Q, KeyEvent.ALT_DOWN_MASK, false))
            .put("2P", KeyStroke.getKeyStroke(KeyEvent.VK_W, KeyEvent.ALT_DOWN_MASK, false))
            .put("3P", KeyStroke.getKeyStroke(KeyEvent.VK_E, KeyEvent.ALT_DOWN_MASK, false))
            .put("1E", KeyStroke.getKeyStroke(KeyEvent.VK_I, KeyEvent.CTRL_DOWN_MASK, false))
            .put("2E", KeyStroke.getKeyStroke(KeyEvent.VK_Y, KeyEvent.CTRL_DOWN_MASK, false))
            .put("3E", KeyStroke.getKeyStroke(KeyEvent.VK_T, KeyEvent.CTRL_DOWN_MASK, false))
            .put("1R", KeyStroke.getKeyStroke(KeyEvent.VK_I, KeyEvent.ALT_DOWN_MASK, false))
            .put("2R", KeyStroke.getKeyStroke(KeyEvent.VK_Y, KeyEvent.ALT_DOWN_MASK, false))
            .put("3R", KeyStroke.getKeyStroke(KeyEvent.VK_T, KeyEvent.ALT_DOWN_MASK, false))
            .build();

    public StemNuDial2e()  {
        this(null);
    }

    public StemNuDial2e(GamePiece piece)
    {
        setInner(piece);

    }

    @Override
    public void mySetState(String newState) {

    }
    /*
    @Override
    public String getState(){

    }
    */

    @Override
    public String myGetState() {
        Integer isHiddenPropCheck = Integer.parseInt(piece.getProperty("isHidden").toString());
        int ownerSide = getOwnerOfThisDial();
        int thisSide = Util.getCurrentPlayer().getSide();

        //sync source is the dial owner, must not pass the owner's vision of a hidden dial
        if(thisSide != ownerSide && isHiddenPropCheck == 1){
            Embellishment chosenMoveEmb = (Embellishment)Util.getEmbellishment(piece,"Layer - Chosen Move");
            Embellishment chosenSpeedEmb = (Embellishment)Util.getEmbellishment(piece, "Layer - Chosen Speed");
            Embellishment sideHideEmb = (Embellishment)Util.getEmbellishment(piece,"Layer - Side Hide");
            Embellishment centralHideEmb = (Embellishment)Util.getEmbellishment(piece, "Layer - Central Hide");
            chosenMoveEmb.setValue(0);
            chosenSpeedEmb.setValue(0);
            sideHideEmb.setValue(0);
            centralHideEmb.setValue(1);
        }

        //sync source is not the dial owner, must pass the owner's vision of a hidden dial
        if(thisSide == ownerSide && isHiddenPropCheck == 1){
            Embellishment chosenMoveEmb = (Embellishment)Util.getEmbellishment(piece,"Layer - Chosen Move");
            Embellishment chosenSpeedEmb = (Embellishment)Util.getEmbellishment(piece, "Layer - Chosen Speed");
            Embellishment sideHideEmb = (Embellishment)Util.getEmbellishment(piece,"Layer - Side Hide");
            Embellishment centralHideEmb = (Embellishment)Util.getEmbellishment(piece, "Layer - Central Hide");
            chosenMoveEmb.setValue(getProperMoveLayer());

            String moveSpeedLayerString = getLayerFromScratch(0);
            chosenSpeedEmb.setValue(Integer.parseInt(moveSpeedLayerString)); //use the right speed layer

            sideHideEmb.setValue(1);
            centralHideEmb.setValue(0);
        }
        return "";
    }


    @Override
    public String myGetType() {
        return ID;
    }
    @Override
    protected KeyCommand[] myGetKeyCommands() {
        return new KeyCommand[0];
    }

    @Override
    public Command myKeyEvent(KeyStroke stroke) { return null; }

    public String buildStateString(int moveModification){
        /*
         * dialString, like: 1BW,1FB,1NW,2TW,2BB,2FB,2NB,2YW,3LR,3TW,3BW,3FW,3NW,3YW,3PR,4FR
         * values, like: [1BW,1FB,1NW,2TW,2BB,2FB,2NB,2YW,3LR,3TW,3BW,3FW,3NW,3YW,3PR,4FR]
         * nbOfMoves, like: 15
         *
         * saveMoveString, like: "4" (out of 15)
         * savedMoveStringInt, like: 4
         *
         * access the move in values by using savedMoveStringInt - 1
         * newMove, like: "1TR"
         * newRawSpeed, like 1
         * newMoveSpeed, like 3 (layer 0 = empty, layer 1 = '0', layer 2 = '1', layer 6 = '5')
         * moveWithoutSpeed, like: "TR"
         * moveImage, like: "1TR.png"
         *
         * stateString, like: "emb2...." which is fed moveImage, moveName
         * moveName, like: "Hard Left 1"
         */

        // Fetch the string of movement from the dynamic property and chop it up in an array
        String dialString = piece.getProperty("dialstring").toString();
        String[] values = dialString.split(",");
        int nbOfMoves = values.length;

        // Fetch the saved move from the dynamic property of the dial piece
        String savedMoveString = piece.getProperty("selectedMove").toString();
        int savedMoveStringInt = Integer.parseInt(savedMoveString);

        if(moveModification == 1){ //if you want to shift the selected move 1 up.
            if(savedMoveStringInt == nbOfMoves) savedMoveStringInt = 1; //loop
            else savedMoveStringInt++;
        } else if(moveModification == -1) //if you want to shift the selected move 1 down
        {
            if (savedMoveStringInt == 1) savedMoveStringInt = nbOfMoves; //loop
            else savedMoveStringInt--;
        }

        String moveCode = values[savedMoveStringInt-1];
        int rawSpeed = getRawSpeedFromMoveCode(moveCode);

        //attempt to seed the move layer with the right image just like at spawn time
        StringBuilder stateString = new StringBuilder();
        StringBuilder moveNamesString = new StringBuilder();
        stateString.append("emb2;Activate;2;;;2;;;2;;;;1;false;0;-24;,");

        String moveImage;
        String moveWithoutSpeed = getMoveCodeWithoutSpeed(moveCode);
        String moveName = StemDial2e.maneuverNames.get(getMoveRaw(moveCode));
        moveNamesString.append(moveName).append(" ").append(rawSpeed);

        moveImage = StemDial2e.dialHeadingImages.get(moveWithoutSpeed);
        stateString.append(moveImage);
        // add in move names
        stateString.append(";empty,"+moveNamesString);
        stateString.append(";false;Chosen Move;;;false;;1;1;true;65,130");

        return stateString.toString();
    }

    @Override
    public Command keyEvent(KeyStroke stroke) {
        boolean hasSomethingHappened = false;
        Integer isHiddenPropCheck;

        ChangeTracker changeTracker = new ChangeTracker(this);
        Command result = piece.keyEvent(stroke);

        isHiddenPropCheck = Integer.parseInt(piece.getProperty("isHidden").toString());

        //Util.logToChat("STEP 0 - keyEvent=" + stroke.getKeyEventType() + " isHidden=" + isHiddenPropCheck);

        if (getOwnerOfThisDial() == Util.getCurrentPlayer().getSide()) {
            KeyStroke checkForCtrlRReleased = KeyStroke.getKeyStroke(KeyEvent.VK_R, KeyEvent.CTRL_DOWN_MASK, false);
            KeyStroke checkForCommaReleased = KeyStroke.getKeyStroke(KeyEvent.VK_COMMA, 0, false);
            KeyStroke checkForPeriodReleased = KeyStroke.getKeyStroke(KeyEvent.VK_PERIOD, 0, false);
            KeyStroke checkForSuperCtrlRReleased = KeyStroke.getKeyStroke(KeyEvent.VK_S, KeyEvent.CTRL_DOWN_MASK, false);
            KeyStroke checkForC = KeyStroke.getKeyStroke(KeyEvent.VK_C, 0, false);

            boolean goingLeft = checkForCommaReleased.equals(stroke);
            boolean goingRight = checkForPeriodReleased.equals(stroke);

            //Util.logToChat("STEP 1 - player side verified " + getOwnerOfThisDial());

            if(checkForCtrlRReleased.equals(stroke) || checkForSuperCtrlRReleased.equals(stroke)) {

                //Util.logToChat("STEP 2a - CTRL-R released");

                hasSomethingHappened = true;

                if(isHiddenPropCheck == 1) { // about to reveal the dial

                    //Construct the next build string
                    StringBuilder stateString = new StringBuilder();
                    stateString.append(buildStateString(0));

                    //get the speed layer to show
                    String moveSpeedLayerString = getLayerFromScratch(0);

                    DialRevealCommand revealNow = new DialRevealCommand(piece, stateString.toString(), moveSpeedLayerString, Util.getCurrentPlayer().getName());
                    revealNow.execute();
                    Command change = changeTracker.getChangeCommand();
                    result.append(revealNow);
                    result.append(change);

                    //logToChat("StemNuDial2e line 261 - dial is looking for=" +this.piece.getProperty("shipID").toString());
                    if(checkForSuperCtrlRReleased.equals(stroke)) {
                        String shipID = this.piece.getProperty("shipID").toString(); //gets the random UUID from the dial that was saved during spawning
                        Collection<GamePiece> pieces = GameModule.getGameModule().getGameState().getAllPieces();
                        Collection<GamePiece> piecesCopied = new ArrayList<GamePiece>(pieces);
                        for (final GamePiece pieceScanned : piecesCopied) {
                            try{
                                String micID = pieceScanned.getProperty("micID").toString();

                               // logToChat("StemNuDial2e line 270 -ship=" +pieceScanned.getProperty("micID").toString());
                                if (micID.equals(shipID) && pieceScanned.getMap().getMapName().equals("Contested Sector") && this.piece.getMap().getMapName().equals("Contested Sector")){
                                    String moveFromScratch = getNewMoveCodeFromScratch(0);
                                    //logToChat("moveFromScratch "+ moveFromScratch);
                                    String moveRaw = moveFromScratch.substring(0,2);
                                    //logToChat("moveRaw " + moveRaw);
                                    KeyStroke thisKey = moveCodeToKeyStroke.get(moveRaw);

                                    //logToChat("found the move? " + foundMoveCode);
                                    if(thisKey!=null) {
                                        Command moveShipCommand = pieceScanned.keyEvent(thisKey);
                                        result.append(moveShipCommand);

                                    }
                                }
                            }catch (Exception e){
                                continue;
                            }
                        }
                    }

                } else if(isHiddenPropCheck == 0){ // about to hide the dial

                    //command shown to all players
                    DialHideCommand hideNow = new DialHideCommand(piece);
                    hideNow.execute();
                    Command change = changeTracker.getChangeCommand();
                    result.append(hideNow);
                    result.append(change);

                    //Stuff outside of a command, should only show for owner.
                    Embellishment chosenMoveEmb = (Embellishment)Util.getEmbellishment(piece,"Layer - Chosen Move");
                    Embellishment chosenSpeedEmb = (Embellishment)Util.getEmbellishment(piece, "Layer - Chosen Speed");
                    Embellishment sideHideEmb = (Embellishment)Util.getEmbellishment(piece,"Layer - Side Hide");
                    Embellishment centralHideEmb = (Embellishment)Util.getEmbellishment(piece, "Layer - Central Hide");

                    /*
                    //Construct the next build string
                    StringBuilder stateString = new StringBuilder();
                    stateString.append(buildStateString(0));
                    */

                    //chosenMoveEmb.mySetType(stateString.toString()); //restore the dial's chosen move like before only for the owner who's doing CTRl-R
                    chosenMoveEmb.setValue(getProperMoveLayer()); //unhide the movement only for the owner who's doing CTRL-R
                    sideHideEmb.setValue(1); //show the side slashed eye icon
                    centralHideEmb.setValue(0); //hide back the central slashed eye icon

                    //get the speed layer to show
                    String moveSpeedLayerString = getLayerFromScratch(0);
                    Integer newMoveSpeed = Integer.parseInt(moveSpeedLayerString);

                    chosenSpeedEmb.setValue(newMoveSpeed); //unhide the speed only for the owner who's doing CTRL-R
                }
            }
            else if(checkForC.equals(stroke)){
                String shipID = this.piece.getProperty("shipID").toString(); //gets the random UUID from the dial that was saved during spawning
                Collection<GamePiece> pieces = GameModule.getGameModule().getGameState().getAllPieces();
                Collection<GamePiece> piecesCopied = new ArrayList<GamePiece>(pieces);
                for (final GamePiece pieceScanned : piecesCopied) {
                    try{
                        String micID = pieceScanned.getProperty("micID").toString();

                        // logToChat("StemNuDial2e line 270 -ship=" +pieceScanned.getProperty("micID").toString());
                        if (micID.equals(shipID) && pieceScanned.getMap().getMapName().equals("Contested Sector") && this.piece.getMap().getMapName().equals("Contested Sector")){
                            Command doCCommand = pieceScanned.keyEvent(checkForC);
                            result.append(doCCommand);

                        }
                    }catch (Exception e){
                        continue;
                    }
                }
            }
            else if(goingLeft || goingRight){ //rotate left, move-- or rotate right, move++

                //Util.logToChat("STEP 2b - , or . released");


                hasSomethingHappened = true;
                int moveMod = 0;
                if(goingLeft) moveMod = -1;
                if(goingRight) moveMod = 1;

                //Construct the next build string
                StringBuilder stateString = new StringBuilder();
                stateString.append(buildStateString(moveMod));

                //Get the movement heading layer
                String moveDef = getNewMoveDefFromScratch(moveMod);
                //get the speed layer to show
                String moveSpeedLayerString = getLayerFromScratch(moveMod);
                Integer newMoveSpeed = Integer.parseInt(moveSpeedLayerString);

                if(piece.getMap().equals(VASSAL.build.module.Map.getMapById("Map0"))) logToChat("* DIAL WARNING - " + Util.getCurrentPlayer().getName() + " has rotated the " + piece.getProperty("Craft ID #").toString()
                        + " (" + piece.getProperty("Pilot Name").toString() + ") on the map. Please use your player window to do so instead.");
                if(isHiddenPropCheck == 1){ //encode only the modified selected move property


                    DialRotateCommand drc = new DialRotateCommand(piece, moveDef, false, getProperMoveLayer()+"", moveSpeedLayerString);

                    drc.execute();
                    result.append(drc);

                    /*
                    DialHideCommand hideNow = new DialHideCommand(piece);
                    GameModule.getGameModule().sendAndLog(hideNow);
                    hideNow.execute();
                    Command change = changeTracker.getChangeCommand();
                    result.append(hideNow);
                    result.append(change);
                     */

                    /*
                    Embellishment chosenMoveEmb = (Embellishment)Util.getEmbellishment(piece,"Layer - Chosen Move");
                    Embellishment chosenSpeedEmb = (Embellishment)Util.getEmbellishment(piece, "Layer - Chosen Speed");
                    chosenMoveEmb.mySetType(stateString.toString());
                    chosenMoveEmb.setValue(1);
                    chosenSpeedEmb.setValue(newMoveSpeed);
*/

                    Command change = changeTracker.getChangeCommand();
                    result.append(change);

                } else if(isHiddenPropCheck == 0) { //dial is revealed, show everything to all

                    logToChat("before selecting move changed? " + changeTracker.isChanged());
                    logToChat(Decorator.getOutermost(piece).getState());
                    logToChat(piece.getProperty("selectedMove").toString());
                    DialRotateCommand drc = new DialRotateCommand(piece, moveDef, true, getProperMoveLayer()+"", moveSpeedLayerString);
                    drc.execute();
                    Command change = changeTracker.getChangeCommand();
                    logToChat("after selecting move changed? " + changeTracker.isChanged());
                    logToChat(Decorator.getOutermost(piece).getState());
                    logToChat(piece.getProperty("selectedMove").toString());
                    change.execute();

                    result.append(drc);
                    result.append(change);
                }
            }
        } else { // get scolded for not owning the dial that was manipulated
            Util.logToChatWithoutUndo("You (player " + Util.getCurrentPlayer().getSide() + ") are not the owner of this dial, player " + getOwnerOfThisDial() + " is.");
        }
        if(hasSomethingHappened) {
            final VASSAL.build.module.Map map = piece.getMap();
            map.repaint();

            GameModule gm = GameModule.getGameModule();
            gm.sendAndLog(result);

            return result;
        }
        //Util.logToChat("STEP 2c - Not a keystroke worth reacting to.");
        return piece.keyEvent(stroke);
    }

    private String getNewMoveDefFromScratch(int moveMod) {
        String dialString = piece.getProperty("dialstring").toString();
        String[] values = dialString.split(",");
        int nbOfMoves = values.length;

        // Fetch the saved move from the dynamic property of the dial piece
        String savedMoveString = piece.getProperty("selectedMove").toString();
        int savedMoveStringInt = Integer.parseInt(savedMoveString);

        if(moveMod == 1){ //if you want to shift the selected move 1 up.
            if(savedMoveStringInt == nbOfMoves) savedMoveStringInt = 1; //loop
            else savedMoveStringInt++;
        } else if(moveMod == -1) //if you want to shift the selected move 1 down
        {
            if (savedMoveStringInt == 1) savedMoveStringInt = nbOfMoves; //loop
            else savedMoveStringInt--;
        }

        return ""+savedMoveStringInt;
    }

    private String getNewMoveCodeFromScratch(int moveMod) {
        String dialString = piece.getProperty("dialstring").toString();
        String[] values = dialString.split(",");
        int nbOfMoves = values.length;

        // Fetch the saved move from the dynamic property of the dial piece
        String savedMoveString = piece.getProperty("selectedMove").toString();
        int savedMoveStringInt = Integer.parseInt(savedMoveString);

        if(moveMod == 1){ //if you want to shift the selected move 1 up.
            if(savedMoveStringInt == nbOfMoves) savedMoveStringInt = 1; //loop
            else savedMoveStringInt++;
        } else if(moveMod == -1) //if you want to shift the selected move 1 down
        {
            if (savedMoveStringInt == 1) savedMoveStringInt = nbOfMoves; //loop
            else savedMoveStringInt--;
        }

        if(moveMod == 1){ //if you want to shift the selected move 1 up.
            if(savedMoveStringInt == nbOfMoves) savedMoveStringInt = 1; //loop
            else savedMoveStringInt++;
        } else if(moveMod == -1) //if you want to shift the selected move 1 down
        {
            if (savedMoveStringInt == 1) savedMoveStringInt = nbOfMoves; //loop
            else savedMoveStringInt--;
        }

        String moveCode = values[savedMoveStringInt-1];

        return moveCode;
    }


    public int getRawSpeedFromMoveCode(String code){
        return Integer.parseInt(code.substring(0,1));
    }
    public int getLayerFromMoveCode(String code){
        return Integer.parseInt(code.substring(0,1)) + 1;
    }
    public String getLayerFromScratch(int moveModification){
        String dialString = piece.getProperty("dialstring").toString();
        String[] values = dialString.split(",");
        int nbOfMoves = values.length;

        // Fetch the saved move from the dynamic property of the dial piece
        String savedMoveString = piece.getProperty("selectedMove").toString();
        int savedMoveStringInt = Integer.parseInt(savedMoveString);

        if(moveModification == 1){ //if you want to shift the selected move 1 up.
            if(savedMoveStringInt == nbOfMoves) savedMoveStringInt = 1; //loop
            else savedMoveStringInt++;
        } else if(moveModification == -1) //if you want to shift the selected move 1 down
        {
            if (savedMoveStringInt == 1) savedMoveStringInt = nbOfMoves; //loop
            else savedMoveStringInt--;
        }

        String moveCode = values[savedMoveStringInt-1];
        Integer moveSpeedLayerToUse = getLayerFromMoveCode(moveCode);
        String moveSpeedLayerString = moveSpeedLayerToUse.toString();

        return moveSpeedLayerString;
    }
    public String getMoveCodeWithoutSpeed(String code){
        return code.substring(1,3);
    }

    public String getMoveRaw(String code){
        return code.substring(1,2);
    }

    public int getProperMoveLayer() {
        String dialString = piece.getProperty("dialstring").toString();
        String[] values = dialString.split(",");
        int nbOfMoves = values.length;

        // Fetch the saved move from the dynamic property of the dial piece
        String savedMoveString = piece.getProperty("selectedMove").toString();
        int savedMoveStringInt = Integer.parseInt(savedMoveString);

        String moveCode = values[savedMoveStringInt-1];
        String moveCodeRaw = getMoveCodeWithoutSpeed(moveCode);

        logToChat("move code raw without speed: " + moveCodeRaw);
        return moveCodeWithColorToLayer.get(moveCodeRaw).intValue();
    }

    public int getOwnerOfThisDial(){
        GamePiece dialPiece = (GamePiece)this.piece;
        String ownerStr = dialPiece.getProperty("owner").toString();
        int ownerInt = Integer.parseInt(ownerStr);
        return ownerInt;
    }
    public String getDescription() {
        return "Custom StemNuDial (mic.StemNuDial2e)";
    }

    public void mySetType(String type) {

    }

    public HelpFile getHelpFile() {
        return null;
    }

    public void draw(Graphics g, int x, int y, Component obs, double zoom) {
        this.piece.draw(g, x, y, obs, zoom);
    }

    public Rectangle boundingBox() {
        return this.piece.boundingBox();
    }

    public Shape getShape() {
        return this.piece.getShape();
    }

    public String getName() {
        return this.piece.getName();
    }
}